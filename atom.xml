<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-18T01:28:27.161Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jeason</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue-移动端控制屏幕缩放</title>
    <link href="http://yoursite.com/2019/10/18/Vue-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%B1%8F%E5%B9%95%E7%BC%A9%E6%94%BE/"/>
    <id>http://yoursite.com/2019/10/18/Vue-移动端控制屏幕缩放/</id>
    <published>2019-10-18T01:22:27.756Z</published>
    <updated>2019-10-18T01:28:27.161Z</updated>
    
    <content type="html"><![CDATA[<p> 在index.html中<head><meta name="generator" content="Hexo 3.9.0">标签下的meta-“name为viewport”中的content属性中补充加入minimum-scale=1.0,maximum-scale=1.0,er-scalable=no即可，示例如下：</head></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,er-scalable=no&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;title&gt;Test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 在index.html中&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.9.0&quot;&gt;标签下的meta-“name为viewport”中的content属性中补充加入minimum-scale=1.0,maximum-scale=1.
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="屏幕缩放" scheme="http://yoursite.com/tags/%E5%B1%8F%E5%B9%95%E7%BC%A9%E6%94%BE/"/>
    
  </entry>
  
  <entry>
    <title>js之“ABC三函数”</title>
    <link href="http://yoursite.com/2019/10/17/js%E4%B9%8B%E2%80%9CABC%E4%B8%89%E5%87%BD%E6%95%B0%E2%80%9D/"/>
    <id>http://yoursite.com/2019/10/17/js之“ABC三函数”/</id>
    <published>2019-10-17T12:46:01.418Z</published>
    <updated>2019-10-17T12:51:25.250Z</updated>
    
    <content type="html"><![CDATA[<h5 id="call、apply-及-bind-函数内部实现是怎么样的？"><a href="#call、apply-及-bind-函数内部实现是怎么样的？" class="headerlink" title="call、apply 及 bind 函数内部实现是怎么样的？"></a>call、apply 及 bind 函数内部实现是怎么样的？</h5><p>首先从以下几点来考虑如何实现这几个函数</p><ul><li>不传入第一个参数，那么上下文默认为 <code>window</code></li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数，并能接受参数</li></ul><h6 id="call的实现："><a href="#call的实现：" class="headerlink" title="call的实现："></a>call的实现：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || window</span><br><span class="line">  context.fn = this</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line">  const result = context.fn(...args)</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是对实现的分析：</p><ul><li>首先 <code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></li><li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数</li><li>因为 <code>call</code> 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</li><li>然后调用函数并将对象上的函数删除</li></ul><p>apply` 的实现也类似于call，区别在于对<strong>参数的处理</strong>，暂不一一分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || window</span><br><span class="line">  context.fn = this</span><br><span class="line">  let result</span><br><span class="line">  // 处理参数和 call 有区别</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    result = context.fn(...arguments[1])</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind<code>的实现对比其他两个函数略微地复杂了一点，因为</code>bind<code>需要返回一个函数，需要判断一些边界问题，以下是</code>bind` 的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  const _this = this</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line">  // 返回一个函数</span><br><span class="line">  return function F() &#123;</span><br><span class="line">    // 因为返回了一个函数，我们可以 new F()，所以需要判断</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return new _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是对实现的分析：</p><ul><li>前几步和之前的实现差不多，就不赘述了</li><li><code>bind</code> 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 <code>new</code> 的方式，我们先来说直接调用的方式</li><li>对于直接调用来说，这里选择了 <code>apply</code> 的方式实现，但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 <code>args.concat(...arguments)</code></li><li>最后来说通过 <code>new</code> 的方式，在之前的章节中我们学习过如何判断 <code>this</code>，对于 <code>new</code> 的情况来说，不会被任何方式改变 <code>this</code>，所以对于这种情况我们需要忽略传入的 <code>this</code> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;call、apply-及-bind-函数内部实现是怎么样的？&quot;&gt;&lt;a href=&quot;#call、apply-及-bind-函数内部实现是怎么样的？&quot; class=&quot;headerlink&quot; title=&quot;call、apply 及 bind 函数内部实现是怎么样的？&quot;&gt;
      
    
    </summary>
    
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
      <category term="apply" scheme="http://yoursite.com/tags/apply/"/>
    
      <category term="bind" scheme="http://yoursite.com/tags/bind/"/>
    
      <category term="call" scheme="http://yoursite.com/tags/call/"/>
    
      <category term="手写" scheme="http://yoursite.com/tags/%E6%89%8B%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>js之“深拷贝”</title>
    <link href="http://yoursite.com/2019/10/17/js%E4%B9%8B%E2%80%9C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E2%80%9D/"/>
    <id>http://yoursite.com/2019/10/17/js之“深拷贝”/</id>
    <published>2019-10-17T12:34:09.252Z</published>
    <updated>2019-10-17T12:45:20.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(source)&#123;</span><br><span class="line">    if(typeof source==(&quot;number&quot;||&quot;string&quot;))&#123;</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!source||typeof source!=&quot;object&quot;)&#123;</span><br><span class="line">        throw new Error(&quot;出错&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    var newSource=source.constructor===&apos;Array&apos;?[]:&#123;&#125;;</span><br><span class="line">    for(var key in source)&#123;</span><br><span class="line">        if(source.hasOwnProperty(key))&#123;</span><br><span class="line">            if(typeof source[key]!==&quot;object&quot;)&#123;</span><br><span class="line">                newSource[key]=source[key];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                newSource[key]=deepClone(source[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return newSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;手写深拷贝&quot;&gt;&lt;a href=&quot;#手写深拷贝&quot; class=&quot;headerlink&quot; title=&quot;手写深拷贝&quot;&gt;&lt;/a&gt;手写深拷贝&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
      <category term="手写" scheme="http://yoursite.com/tags/%E6%89%8B%E5%86%99/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="深拷贝" scheme="http://yoursite.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件通信</title>
    <link href="http://yoursite.com/2019/10/17/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/10/17/Vue组件通信/</id>
    <published>2019-10-17T12:29:02.895Z</published>
    <updated>2019-10-17T12:35:54.273Z</updated>
    
    <content type="html"><![CDATA[<p>组件通信一般分为以下几种情况：</p><ul><li>父子组件通信</li><li>兄弟组件通信</li><li>跨多层级组件通信</li><li>任意组件</li></ul><p>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</p><h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><p>父组件通过 <code>props</code> 传递数据给子组件，子组件通过 <code>emit</code> 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</p><p>这种父子通信方式也就是典型的单向数据流，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>， 而是必须通过发送事件的方式告知父组件修改数据。</p><p>另外这两种方式还可以使用语法糖 <code>v-model</code> 来直接实现，因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</p><p>当然我们还可以通过访问 <code>$parent</code> 或者 <code>$children</code> 对象来访问组件实例中的方法和数据。</p><p>另外如果你使用 Vue 2.3 及以上版本的话还可以使用 <code>$listeners</code> 和 <code>.sync</code> 这两个属性。</p><p><code>$listeners</code> 属性会将父组件中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器传递给子组件，子组件可以通过访问 <code>$listeners</code> 来自定义监听器。</p><p><code>.sync</code> 属性是个语法糖，可以很简单的实现子组件与父组件通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line">&lt;input :value.sync=&quot;value&quot; /&gt;</span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line">&lt;input :value=&quot;value&quot; @update:value=&quot;v =&gt; value = v&quot;&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  this.$emit(&apos;update:value&apos;, 1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>对于这种情况可以通过查找父组件中的子组件实现，也就是 <code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>对于这种情况可以使用 Vue 2.2 新增的 API <code>provide / inject</code>，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p><p>假设有父组件 A，然后有一个跨多层级的子组件 B</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件 A</span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子组件 B</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&apos;data&apos;],</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    // 无论跨几层都能获得父组件的 data 属性</span><br><span class="line">    console.log(this.data) // =&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><p>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组件通信一般分为以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父子组件通信&lt;/li&gt;
&lt;li&gt;兄弟组件通信&lt;/li&gt;
&lt;li&gt;跨多层级组件通信&lt;/li&gt;
&lt;li&gt;任意组件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="组件" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>My Blog</title>
    <link href="http://yoursite.com/2019/10/16/%E4%BF%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/10/16/俺的博客/</id>
    <published>2019-10-16T01:27:24.090Z</published>
    <updated>2019-10-16T12:07:04.793Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to My Blog zone~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to My Blog zone~~&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="start" scheme="http://yoursite.com/tags/start/"/>
    
  </entry>
  
  <entry>
    <title>Git简单教程</title>
    <link href="http://yoursite.com/2019/10/15/GIT%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/15/GIT简单教程/</id>
    <published>2019-10-15T12:54:28.764Z</published>
    <updated>2019-10-17T12:35:40.324Z</updated>
    
    <content type="html"><![CDATA[<p>前端之路</p><h2 id="Git-是什么？"><a href="#Git-是什么？" class="headerlink" title="Git   -是什么？"></a>Git   -是什么？</h2><p>Git是目前世界上最先进的分布式版本控制系统，它没有中央服务器。</p><p>工作原理如下：</p><p><img src="https://img.mukewang.com/59c31e4400013bc911720340.png" alt="git1"></p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>从官网下载安装包——（<a href="https://git-scm.com/downloads）" target="_blank" rel="noopener">https://git-scm.com/downloads）</a></p><p>接着安装到指定位置。</p><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>在Git Bash中配置个人用户信息（前提是已完成注册）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name XXXX</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email XXXX</span><br></pre></td></tr></table></figure><h3 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3.创建版本库"></a>3.创建版本库</h3><p>在指定位置下通过以下代码初始化git版本库即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><h3 id="4-设置秘钥ssh"><a href="#4-设置秘钥ssh" class="headerlink" title="4.设置秘钥ssh"></a>4.设置秘钥ssh</h3><p>由于本地Git仓库和github仓库之间的传输是通过SSH加密的，因此需要配置相关ssh key</p><p>先创建SSH Key，在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa –C “youremail@example.com”</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/59c1d7d7000120d107530169.png" alt="59c1d7d7000120d107530169"></p><p>id_rsa是私钥；而id_rsa.pub是公钥。</p><p>然后，登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。<img src="https://img.mukewang.com/59c1d7ef0001c75411330860.png" alt="5"></p><p>点击 Add Key即可。</p><h3 id="5-创建仓库并在本地文件上传至git"><a href="#5-创建仓库并在本地文件上传至git" class="headerlink" title="5.创建仓库并在本地文件上传至git"></a>5.创建仓库并在本地文件上传至git</h3><p>首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><p><img src="https://img.mukewang.com/59c1d86a0001044b10840605.png" alt="59c"></p><p>在本地，可以先查看当前目标文件夹的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p>再使用add命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add *</span><br></pre></td></tr></table></figure><p>通过commit添加当前版本注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;XXX&quot;</span><br></pre></td></tr></table></figure><p>复制刚刚创建完的github的空仓库的shh码<img src="https://img.mukewang.com/59c1d8850001b5ea10260661.png" alt="微49"></p><p>通过上方的git push -u origin master命令即可传至github仓库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端之路&lt;/p&gt;
&lt;h2 id=&quot;Git-是什么？&quot;&gt;&lt;a href=&quot;#Git-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Git   -是什么？&quot;&gt;&lt;/a&gt;Git   -是什么？&lt;/h2&gt;&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统，它没有中央
      
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="仓库同步" scheme="http://yoursite.com/tags/%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
</feed>
