{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Jeason","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-10-16T00:53:10.000Z","updated":"2019-10-16T00:53:10.450Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"books","date":"2019-10-16T00:53:28.000Z","updated":"2019-10-16T00:53:28.427Z","comments":true,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-16T01:40:13.000Z","updated":"2019-10-16T01:48:39.363Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"repository","date":"2019-10-16T00:52:53.000Z","updated":"2019-10-16T00:52:53.382Z","comments":true,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-16T00:52:33.000Z","updated":"2019-10-16T03:01:52.256Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue-移动端控制屏幕缩放","slug":"Vue-移动端控制屏幕缩放","date":"2019-10-18T01:22:27.756Z","updated":"2019-10-18T01:28:27.161Z","comments":true,"path":"2019/10/18/Vue-移动端控制屏幕缩放/","link":"","permalink":"http://yoursite.com/2019/10/18/Vue-移动端控制屏幕缩放/","excerpt":"","text":"在index.html中标签下的meta-“name为viewport”中的content属性中补充加入minimum-scale=1.0,maximum-scale=1.0,er-scalable=no即可，示例如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,er-scalable=no&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"屏幕缩放","slug":"屏幕缩放","permalink":"http://yoursite.com/tags/屏幕缩放/"}]},{"title":"js之“ABC三函数”","slug":"js之“ABC三函数”","date":"2019-10-17T12:46:01.418Z","updated":"2019-10-17T12:51:25.250Z","comments":true,"path":"2019/10/17/js之“ABC三函数”/","link":"","permalink":"http://yoursite.com/2019/10/17/js之“ABC三函数”/","excerpt":"","text":"call、apply 及 bind 函数内部实现是怎么样的？首先从以下几点来考虑如何实现这几个函数 不传入第一个参数，那么上下文默认为 window 改变了 this 指向，让新的对象可以执行该函数，并能接受参数 call的实现：1234567891011Function.prototype.myCall = function(context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; context = context || window context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) delete context.fn return result&#125; 以下是对实现的分析： 首先 context 为可选参数，如果不传的话默认上下文为 window 接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数 因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来 然后调用函数并将对象上的函数删除 apply` 的实现也类似于call，区别在于对参数的处理，暂不一一分析。 12345678910111213141516Function.prototype.myApply = function(context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; context = context || window context.fn = this let result // 处理参数和 call 有区别 if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; bind的实现对比其他两个函数略微地复杂了一点，因为bind需要返回一个函数，需要判断一些边界问题，以下是bind` 的实现 123456789101112131415Function.prototype.myBind = function (context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; const _this = this const args = [...arguments].slice(1) // 返回一个函数 return function F() &#123; // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) &#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125;&#125; 以下是对实现的分析： 前几步和之前的实现差不多，就不赘述了 bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式 对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(...arguments) 最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"apply","slug":"apply","permalink":"http://yoursite.com/tags/apply/"},{"name":"bind","slug":"bind","permalink":"http://yoursite.com/tags/bind/"},{"name":"call","slug":"call","permalink":"http://yoursite.com/tags/call/"},{"name":"手写","slug":"手写","permalink":"http://yoursite.com/tags/手写/"}]},{"title":"js之“深拷贝”","slug":"js之“深拷贝”","date":"2019-10-17T12:34:09.252Z","updated":"2019-10-17T12:45:20.906Z","comments":true,"path":"2019/10/17/js之“深拷贝”/","link":"","permalink":"http://yoursite.com/2019/10/17/js之“深拷贝”/","excerpt":"","text":"手写深拷贝12345678910111213141516171819function deepClone(source)&#123; if(typeof source==(&quot;number&quot;||&quot;string&quot;))&#123; return source; &#125; if(!source||typeof source!=&quot;object&quot;)&#123; throw new Error(&quot;出错&quot;); &#125; var newSource=source.constructor===&apos;Array&apos;?[]:&#123;&#125;; for(var key in source)&#123; if(source.hasOwnProperty(key))&#123; if(typeof source[key]!==&quot;object&quot;)&#123; newSource[key]=source[key]; &#125;else&#123; newSource[key]=deepClone(source[key]); &#125; &#125; &#125;; return newSource;&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"手写","slug":"手写","permalink":"http://yoursite.com/tags/手写/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"深拷贝","slug":"深拷贝","permalink":"http://yoursite.com/tags/深拷贝/"}]},{"title":"Vue组件通信","slug":"Vue组件通信","date":"2019-10-17T12:29:02.895Z","updated":"2019-10-17T12:35:54.273Z","comments":true,"path":"2019/10/17/Vue组件通信/","link":"","permalink":"http://yoursite.com/2019/10/17/Vue组件通信/","excerpt":"","text":"组件通信一般分为以下几种情况： 父子组件通信 兄弟组件通信 跨多层级组件通信 任意组件 对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。 父子通信父组件通过 props 传递数据给子组件，子组件通过 emit 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。 这种父子通信方式也就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props， 而是必须通过发送事件的方式告知父组件修改数据。 另外这两种方式还可以使用语法糖 v-model 来直接实现，因为 v-model 默认会解析成名为 value 的 prop 和名为 input 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。 当然我们还可以通过访问 $parent 或者 $children 对象来访问组件实例中的方法和数据。 另外如果你使用 Vue 2.3 及以上版本的话还可以使用 $listeners 和 .sync 这两个属性。 $listeners 属性会将父组件中的 (不含 .native 修饰器的) v-on 事件监听器传递给子组件，子组件可以通过访问 $listeners 来自定义监听器。 .sync 属性是个语法糖，可以很简单的实现子组件与父组件通信 12345678&lt;!--父组件中--&gt;&lt;input :value.sync=&quot;value&quot; /&gt;&lt;!--以上写法等同于--&gt;&lt;input :value=&quot;value&quot; @update:value=&quot;v =&gt; value = v&quot;&gt;&lt;/comp&gt;&lt;!--子组件中--&gt;&lt;script&gt; this.$emit(&apos;update:value&apos;, 1)&lt;/script&gt; 兄弟组件通信对于这种情况可以通过查找父组件中的子组件实现，也就是 this.$parent.$children，在 $children 中可以通过组件 name 查询到需要的组件实例，然后进行通信。 跨多层次组件通信对于这种情况可以使用 Vue 2.2 新增的 API provide / inject，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。 假设有父组件 A，然后有一个跨多层级的子组件 B 1234567891011121314// 父组件 Aexport default &#123; provide: &#123; data: 1 &#125;&#125;// 子组件 Bexport default &#123; inject: [&apos;data&apos;], mounted() &#123; // 无论跨几层都能获得父组件的 data 属性 console.log(this.data) // =&gt; 1 &#125;&#125; 任意组件这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/组件/"}]},{"title":"My Blog","slug":"俺的博客","date":"2019-10-16T01:27:24.090Z","updated":"2019-10-16T12:07:04.793Z","comments":true,"path":"2019/10/16/俺的博客/","link":"","permalink":"http://yoursite.com/2019/10/16/俺的博客/","excerpt":"","text":"Welcome to My Blog zone~~","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"start","slug":"start","permalink":"http://yoursite.com/tags/start/"}]},{"title":"Git简单教程","slug":"GIT简单教程","date":"2019-10-15T12:54:28.764Z","updated":"2019-10-17T12:35:40.324Z","comments":true,"path":"2019/10/15/GIT简单教程/","link":"","permalink":"http://yoursite.com/2019/10/15/GIT简单教程/","excerpt":"","text":"前端之路 Git -是什么？Git是目前世界上最先进的分布式版本控制系统，它没有中央服务器。 工作原理如下： 1.安装从官网下载安装包——（https://git-scm.com/downloads） 接着安装到指定位置。 2.配置在Git Bash中配置个人用户信息（前提是已完成注册） 1$ git config --global user.name XXXX 1$ git config --global user.email XXXX 3.创建版本库在指定位置下通过以下代码初始化git版本库即可。 1$ git init 4.设置秘钥ssh由于本地Git仓库和github仓库之间的传输是通过SSH加密的，因此需要配置相关ssh key 先创建SSH Key，在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令： 1$ ssh-keygen -t rsa –C “youremail@example.com” id_rsa是私钥；而id_rsa.pub是公钥。 然后，登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。 点击 Add Key即可。 5.创建仓库并在本地文件上传至git首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下： 在本地，可以先查看当前目标文件夹的状态： 1$ git status 再使用add命令 1$ git add * 通过commit添加当前版本注释 1$ git commit -m &quot;XXX&quot; 复制刚刚创建完的github的空仓库的shh码 通过上方的git push -u origin master命令即可传至github仓库。","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"仓库同步","slug":"仓库同步","permalink":"http://yoursite.com/tags/仓库同步/"}]}]}